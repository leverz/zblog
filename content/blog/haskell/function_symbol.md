---
title: Haskell小白之 区分 ($) 和 (.) 两个函数
date: '2017-06-03T16:38:00.000Z'
---

每次看 Haskell 代码，看到一堆 ($) 和 (.) 混杂在一块儿，总是让人一下子摸不着头脑。像我这样的半吊子选手，经常一段时间不看，这两位就又分不清了。算了，这次就把他俩的区别写一写，理理清楚，彻底搞明白这俩大兄弟。

按照了解一个 Haskell 中函数的基本套路，先去分析他们的类型声明：

```Haskell
($) :: (a -> b) -> a -> b
(.) :: (b -> c) -> (a -> b) -> a -> c
```

是不是一目了然？

($)
---

从类型声明中可以看出，($) 函数接受两个参数 —— (a -> b) 和 a ，而这个函数的返回值与其第一个参数的返回值相同，（它的第一个参数本身就是函数）。举个例子：

```
f $ x
```

这个例子其实等同于 f x，这不就是相当于直接对 (a -> b) 这个函数直接应用 a 这个输入么。那么 ($) 本身存在的意义是什么呢？

($) 这个符号，在Haskell中叫做**函数应用符**，它主要被用来降低函数的优先级，即这个函数具有右结合性，这又怎么理解呢？

```
f a b c
-- 这个函数在Haskell中等同于
(((f a) b) c)
-- 但是如果你的需求是这样的呢
f a (b c)
-- 即先计算最右侧的表达式的值，那我们就可以用 $ 来代替括号了
f a $ b c
```

所以 ($) 函数在Haskell中的主要用途就是来减少括号的使用的，让代码看上去更简洁。再举个实际的例子：

```
3 * (1 + 2)
-- 换成用 $ 表达 可以写成
(*) 3 $ 1 + 2
```

当然这个例子还不太能够展示 $ 的优势，我们再举个例子(前方高能)：

```
sum (filter (>10) (map (*2) [2..10]))
-- 将2-10这9个数字分别乘2得到一个新数组，然后过滤掉数组中大于10的数，将剩余的
-- 数字求和，最后结果为80
-- 使用 $ 后，变成了这样
sum $ filter (>10) $ map (*2) [2..10]

sum (map sqrt [1..130])
-- 等价于
sum $ map sqrt [1..130]

length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1
-- 等价于
(+1) $ length $ takeWhile (<1000) $ scanl1 (+) $ map sqrt [1..]
```


(.)
---

从类型声明中可以看出来，(.) 函数实际上将 (b -> c) . (a -> b) 重新糅合成一个新的函数，即 (a -> c)。想必你也能猜到了，(.)的作用就是组合函数，将两个函数组合成一个新的函数，第二个参数的输出，是第一个参数的输入，并且新生成的这个函数，以第二个参数的输入作为输入，以第一个参数的输出作为输出。用数学来表示，就是这样的 **(f · g)(x) = f(g(x))**。

```
-- 数学表述如下：
-- f(x) = x + 1
-- g(x) = 2x
-- o(x) = f(g(x))
-- 现在我们要的到o这样一个函数，使用函数组合就是下面这个样子
(+1).(*2)
-- 等价于
(\x -> x * 2) + 1
```


可以看出使用 (.) 函数，可以很方便的进行函数组合，而无需再出现多余的 lambda 表达式。

(.) 和 ($) 配合起来使用，可以省去很多括号，让代码看起来十分简洁(前方高能):

```
-- 不使用的写法
replicate 2 (product (map (*3) (zipWith max [1, 2] [4, 5])))
-- 使用之后
replicate 2 . product . map (*3) $ zipWith max [1, 2] [4, 5]
-- 还可以这样
replicate 2 . product . map (*3) . zipWith max [1, 2] $ [4, 5]
```

是不是简洁了很多。

总结
--

经过刚刚的梳理，可以看到两者有本质上的不同，但由于 ($) 和 (.) 经常会同时出现在代码中，如果基础不够扎实，还是会很容易把两者搞混。为了区分他们，只需要时刻谨记 —— (.) 是用来做函数组合的，($) 是用来降低函数执行优先级的。

